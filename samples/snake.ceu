#define DIM 30

emit WINDOW_SET_TITLE("Snake");
emit WINDOW_SET_SIZE(DIM*10,DIM*10,DIM,DIM);

data Direction;
data Direction.Left;
data Direction.Right;
data Direction.Up;
data Direction.Down;

code/await Snake (none) -> (event void grow) -> void do
    vector[DIM*DIM] Point body;

    var Point pt_ = val Point(-1,-1);
    var integer i;
    loop i in [0 -> ($$body as integer)[ do
        body = body .. [pt_];
    end

    var Point pt = val Point(DIM/2,DIM/2);
    body[0] = pt;

    var integer len  = 1;
    var integer head = 0;
    var integer tail = 0;

    code/tight Is_Free (var& Point pt1) -> yesno do
        var integer i;
        loop i in [0 -> outer.len[ do
            var integer ii = (outer.tail+i) % ($outer.body as integer);
            var Point pt2 = outer.body[ii];
            if pt2.x==pt1.x and pt2.y==pt1.y then
                escape no;
            end
        end
        escape yes;
    end

    var Direction dir = val Direction.Right();
    var Direction nxt = val Direction.Right();

    var bool to_grow = false;
    spawn do
        every grow do
            to_grow = true;
        end
    end

    par do
        var integer key;
        every key in KEY_PRESS do
            if      key==KEY_LEFT  and
                    not ((dir is Direction.Left)  or (dir is Direction.Right))
            then
                nxt = val Direction.Left();
            else/if key==KEY_RIGHT and
                    not ((dir is Direction.Right) or (dir is Direction.Left))
            then
                nxt = val Direction.Right();
            else/if key==KEY_UP    and
                    not ((dir is Direction.Up)    or (dir is Direction.Down))
            then
                nxt = val Direction.Up();
            else/if key==KEY_DOWN  and
                    not ((dir is Direction.Down)  or (dir is Direction.Up))
            then
                nxt = val Direction.Down();
            end
        end
    with
        every 250ms do
            dir = nxt;
            var Point pt = body[head];
            if dir is Direction.Left then
                pt.x = pt.x - 1;
            else/if dir is Direction.Right then
                pt.x = pt.x + 1;
            else/if dir is Direction.Up then
                pt.y = pt.y - 1;
            else/if dir is Direction.Down then
                pt.y = pt.y + 1;
            end

            head = (head + 1) % ($body as integer);
            body[head] = pt;
            if to_grow then
                to_grow = false;
                len = len + 1;
            else
                tail = (tail + 1) % ($body as integer);
            end
            _ceu_dbg_assert(len <= DIM*DIM);
        end
    with
        every FRAMES_REDRAW do
            var integer i;
            loop i in [0 -> len[ do
                var integer ii = (tail+i) % ($body as integer);
                var Point pt = body[ii];
                emit GRAPHICS_SET_COLOR_NAME(COLOR_WHITE);
                emit GRAPHICS_DRAW_PIXEL(pt.x,pt.y);
            end
        end
    with
        loop do
            await FRAMES_UPDATE;
            var Point hd = body[head];
            if hd.x<0 or hd.x>=DIM or hd.y<0 or hd.y>=DIM then
                escape;
            end
            var integer i;
            loop i in [0 -> len-2] do
                var integer ii = (tail+i) % ($body as integer);
                var Point pt = body[ii];
                if pt.x==hd.x and pt.y==hd.y then
                    escape;
                end
            end
        end
    end
end

code/await Food (var&? Snake snake) -> (var Point pt) -> FOREVER do
    loop do
        pt = val Point(_rand()%DIM, _rand()%DIM);
        if call snake!.Is_Free(&pt) then
            break;
        end
    end

    every FRAMES_REDRAW do
        emit GRAPHICS_SET_COLOR_NAME(COLOR_RED);
        emit GRAPHICS_DRAW_PIXEL(pt.x,pt.y);
    end
end

loop do
    emit FRAMES_SET(no);
    emit GRAPHICS_SET_COLOR_NAME(COLOR_BLACK);
    emit GRAPHICS_CLEAR();
    emit GRAPHICS_SET_COLOR_NAME(COLOR_WHITE);
    emit GRAPHICS_SET_FONT("res/tiny.ttf", 10);
    emit GRAPHICS_SET_WRITE_CURSOR(1, 0);
    emit GRAPHICS_WRITELN("PRESS");
    emit GRAPHICS_WRITELN(" ANY ");
    emit GRAPHICS_WRITELN(" KEY ");
    await KEY_PRESS;

    emit FRAMES_SET(yes);
    emit FRAMES_SET_CLEAR_COLOR_NAME(COLOR_BLACK);

    var&? Snake snake = spawn Snake();

    pool[] Food foods;
    par/or do
        await snake;
    with
        every 5s do
            spawn Food(&snake) in foods;
        end
    with
        every FRAMES_UPDATE do
            var&? Food food;
            loop food in foods do
                if not call snake!.Is_Free(&food!.pt) then
                    emit snake!.grow;
                    kill food;
                    break;
                end
            end
        end
    end
end
