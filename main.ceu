#define WIN_DIM 400

#include "c.ceu"
#include "sdl/sdl.ceu"
#include "keys.ceu"

native/plain _none, _yesno, _integer, _real, _text;
native/pre do
    typedef void  none;
    typedef bool  yesno;
    typedef int   integer;
    typedef float real;
    typedef char* text;
end
#define none    void
#define yesno   bool
#define integer int
#define real    float
#define text    _text
#define yes     true
#define no      false

output (text)            WINDOW_SET_TITLE;
output (int,int,int,int) WINDOW_SET_SIZE;

output (bool)            FRAMES_SET;
output (int,int,int)     FRAMES_SET_CLEAR_RGB;
input  (int)             FRAMES_UPDATE;
input  (void)            FRAMES_REDRAW;

input (bool,int,int,int) MOUSE_CLICK;
input (int,int)          MOUSE_MOVE;
input (bool,int)         KEY_PRESS;

output (int,int,int)     GFX_SET_RGB;
output (text,int)        GFX_SET_TEXT_FONT;
output (int,int)         GFX_SET_TEXT_CURSOR;
output (bool)            GFX_SET_GRID;
output (text)            GFX_SCREENSHOT;
output (void)            GFX_CLEAR;
output (int,int)         GFX_DRAW_PIXEL;
output (int,int,int,int) GFX_DRAW_RECT;
output (text,int,int)    GFX_DRAW_BMP;
output (text)            GFX_DRAW_TEXT;
output (text)            GFX_DRAW_TEXTLN;

native/pos do
    SDL_Window*   WIN;
    #define REN (SDL_GetRenderer(WIN))

    TTF_Font* FNT = NULL;
    int       FNT_H;

    bool      FRAMES_SET = 0;
    SDL_Color FRAMES_SET_CLEAR_RGB;

    bool GFX_SET_GRID = 0;
    int  GFX_TEXT_CURSOR_X = 0;
    int  GFX_TEXT_CURSOR_Y = 0;

    void GFX_Show_Grid (void) {
        if (!GFX_SET_GRID) return;

        int ren_w,ren_h, log_w,log_h;
        SDL_GetRendererOutputSize(REN, &ren_w, &ren_h);
        SDL_RenderGetLogicalSize(REN, &log_w, &log_h);
        SDL_RenderSetLogicalSize(REN, ren_w, ren_h);

        u8 r, g, b;
        SDL_GetRenderDrawColor(REN, &r,&g,&b, NULL);

        SDL_SetRenderDrawColor(REN, 0x77,0x77,0x77, 0x00);
        for (int i=0; i<=ren_w; i+=(ren_w/log_w)) {
            SDL_RenderDrawLine(REN, i, 0, i, ren_h);
        }
        for (int j=0; j<=ren_h; j+=(ren_h/log_h)) {
            SDL_RenderDrawLine(REN, 0, j, ren_w, j);
        }

        SDL_SetRenderDrawColor(REN, r,g,b, 0xFF);
        SDL_RenderSetLogicalSize(REN, log_w, log_w);
    }

    void GFX_Present (void) {
        if (FRAMES_SET) return;
        GFX_Show_Grid();
        SDL_RenderPresent(REN);
    }

    tceu_callback_ret ceu_callback_sdl_edu (int cmd, tceu_callback_arg p1, tceu_callback_arg p2) {
        tceu_callback_ret ret;
        switch (cmd) {
            case CEU_CALLBACK_OUTPUT:
                switch (p1.num) {
                    case CEU_OUTPUT_WINDOW_SET_TITLE: {
                        char** title = (char**) p2.ptr;
                        SDL_SetWindowTitle(WIN, *title);
                        break;
                    }
                    case CEU_OUTPUT_WINDOW_SET_SIZE: {
                        tceu_output_WINDOW_SET_SIZE* ps = (tceu_output_WINDOW_SET_SIZE*) p2.ptr;
                        int ren_w = ps->_1;
                        int ren_h = ps->_2;
                        int log_w = ps->_3;
                        int log_h = ps->_4;
                        ceu_dbg_assert(ren_w%log_w == 0);
                        ceu_dbg_assert(ren_h%log_h == 0);

                        SDL_SetWindowSize(WIN, ren_w, ren_h);
                        SDL_RenderSetLogicalSize(REN, log_w, log_h);
                        break;
                    }

                    case CEU_OUTPUT_FRAMES_SET: {
                        bool* on = (bool*) p2.ptr;
                        FRAMES_SET = *on;
                        break;
                    }
                    case CEU_OUTPUT_FRAMES_SET_CLEAR_RGB: {
                        tceu_output_FRAMES_SET_CLEAR_RGB* clr = (tceu_output_FRAMES_SET_CLEAR_RGB*) p2.ptr;
                        FRAMES_SET_CLEAR_RGB.r = clr->_1;
                        FRAMES_SET_CLEAR_RGB.g = clr->_2;
                        FRAMES_SET_CLEAR_RGB.b = clr->_3;
                        FRAMES_SET_CLEAR_RGB.a = 0xFF;
                        break;
                    }

                    case CEU_OUTPUT_GFX_SET_RGB: {
                        tceu_output_GFX_SET_RGB* clr = (tceu_output_GFX_SET_RGB*) p2.ptr;
                        SDL_SetRenderDrawColor(REN, clr->_1, clr->_2, clr->_3, 0xFF);
                        break;
                    }
                    case CEU_OUTPUT_GFX_SET_TEXT_FONT: {
                        tceu_output_GFX_SET_TEXT_FONT* fnt = (tceu_output_GFX_SET_TEXT_FONT*) p2.ptr;
                        FNT_H = fnt->_2;
                        if (FNT != NULL) {
                            TTF_CloseFont(FNT);
                        }
                        FNT = TTF_OpenFont(fnt->_1, FNT_H);
                        ceu_dbg_assert(FNT != NULL);
                        break;
                    }
                    case CEU_OUTPUT_GFX_SET_TEXT_CURSOR: {
                        tceu_output_GFX_SET_TEXT_CURSOR* pt = (tceu_output_GFX_SET_TEXT_CURSOR*) p2.ptr;
                        GFX_TEXT_CURSOR_X = pt->_1;
                        GFX_TEXT_CURSOR_Y = pt->_2;
                        break;
                    }

                    case CEU_OUTPUT_GFX_SET_GRID: {
                        bool* on = (bool*) p2.ptr;
                        GFX_SET_GRID = *on;

                        int ren_w,ren_h, log_w,log_h;
                        SDL_GetRendererOutputSize(REN, &ren_w, &ren_h);
                        SDL_RenderGetLogicalSize(REN, &log_w, &log_h);
                        ceu_dbg_assert(ren_w/log_w>1 && ren_h/log_h>1);
                        break;
                    }

                    case CEU_OUTPUT_GFX_SCREENSHOT: {
                        char** path = (char**) p2.ptr;
                        int ren_w,ren_h, log_w,log_h;
                        SDL_GetRendererOutputSize(REN, &ren_w, &ren_h);
                        SDL_RenderGetLogicalSize(REN, &log_w, &log_h);


                        SDL_Surface* src_sfc = SDL_CreateRGBSurface(0, ren_w, ren_h, 32,
                                                0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
                        SDL_RenderReadPixels(REN, NULL, SDL_PIXELFORMAT_ARGB8888, src_sfc->pixels, src_sfc->pitch);
                        SDL_Texture* src_tex = SDL_CreateTextureFromSurface(REN, src_sfc);
                        SDL_FreeSurface(src_sfc);

                        SDL_Texture* dst_tex = SDL_CreateTexture(REN, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, log_w, log_h);
                        SDL_SetRenderTarget(REN, dst_tex);

                        // TODO: why flipping?
                        //SDL_RenderCopy(REN, src_tex, NULL, NULL);
                        SDL_RenderCopyEx(REN, src_tex, NULL, NULL, 0, NULL, SDL_FLIP_VERTICAL);

                        SDL_DestroyTexture(src_tex);

                        SDL_Surface* sav_sfc = SDL_CreateRGBSurface(0, log_w, log_h, 32,
                                                0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
                        SDL_RenderReadPixels(REN, NULL, SDL_PIXELFORMAT_ARGB8888, sav_sfc->pixels, sav_sfc->pitch);
                        ceu_dbg_assert(0 == SDL_SaveBMP(sav_sfc,*path));
                        SDL_FreeSurface(sav_sfc);

                        SDL_SetRenderTarget(REN, NULL);
                        SDL_DestroyTexture(dst_tex);
                        break;
                    }

                    case CEU_OUTPUT_GFX_CLEAR: {
// TODO: w/o double Fill/Present, a "SET_WINDOW();CLEAR()" doesn't work
#if 1
                        SDL_RenderFillRect(REN, NULL);
                        if (!FRAMES_SET) {
                            SDL_RenderPresent(REN);
                        }
#endif
                        SDL_RenderFillRect(REN, NULL);
                        GFX_Present();
                        break;
                    }

                    case CEU_OUTPUT_GFX_DRAW_PIXEL: {
                        tceu_output_GFX_DRAW_PIXEL* pt = (tceu_output_GFX_DRAW_PIXEL*) p2.ptr;
                        SDL_Rect rct = { pt->_1, pt->_2, 1, 1 };
                        SDL_RenderFillRect(REN, &rct);
                        GFX_Present();
                        break;
                    }
                    case CEU_OUTPUT_GFX_DRAW_RECT: {
                        tceu_output_GFX_DRAW_RECT* pt = (tceu_output_GFX_DRAW_RECT*) p2.ptr;
                        SDL_Rect rct = { pt->_1, pt->_2, pt->_3, pt->_4 };
                        SDL_RenderFillRect(REN, &rct);
                        GFX_Present();
                        break;
                    }
                    case CEU_OUTPUT_GFX_DRAW_BMP: {     // TODO: chache
                        tceu_output_GFX_DRAW_BMP* ps = (tceu_output_GFX_DRAW_BMP*) p2.ptr;
                        SDL_Surface* sfc = SDL_LoadBMP(ps->_1);
                        ceu_dbg_assert(sfc != NULL);
                        SDL_Texture* tex = SDL_CreateTextureFromSurface(REN, sfc);
                        ceu_dbg_assert(tex != NULL);

                        SDL_Rect rct = { ps->_2,ps->_3, sfc->w,sfc->h };
                        SDL_RenderCopy(REN, tex, NULL, &rct);
                        GFX_Present();

                        SDL_DestroyTexture(tex);
                        SDL_FreeSurface(sfc);
                        break;
                    }

                    case CEU_OUTPUT_GFX_DRAW_TEXT: {        // TODO: cache
                        char** str = (char**) p2.ptr;
                        ceu_dbg_assert(FNT != NULL);

                        u8 r, g, b;
                        SDL_GetRenderDrawColor(REN, &r,&g,&b, NULL);
                        SDL_Surface* sfc = TTF_RenderText_Blended(FNT, *str, (SDL_Color){r,g,b,0xFF});
                        ceu_dbg_assert(sfc != NULL);
                        SDL_Texture* tex = SDL_CreateTextureFromSurface(REN, sfc);
                        ceu_dbg_assert(tex != NULL);

                        int w, h;
                        TTF_SizeText(FNT, *str, &w,&h);
                        SDL_Rect rct = { GFX_TEXT_CURSOR_X,GFX_TEXT_CURSOR_Y, w,h };
                        SDL_RenderCopy(REN, tex, NULL, &rct);
                        GFX_Present();

                        GFX_TEXT_CURSOR_X += w;

                        SDL_DestroyTexture(tex);
                        SDL_FreeSurface(sfc);
                        break;
                    }
                    case CEU_OUTPUT_GFX_DRAW_TEXTLN: {
                        int cursor_x = GFX_TEXT_CURSOR_X;
                        p1.num = CEU_OUTPUT_GFX_DRAW_TEXT;
                        ceu_callback_sdl_edu(cmd, p1, p2);
                        GFX_TEXT_CURSOR_X = cursor_x;
                        GFX_TEXT_CURSOR_Y += FNT_H;
                        break;
                    }
                }
                break;
            default:
                ret.is_handled = 0;
        }
        return ret;
    }
    static tceu_callback CEU_CALLBACK_EDU = { &ceu_callback_sdl_edu, NULL };
end

{
    ceu_callback_register(&CEU_CALLBACK_EDU);
}

var&? SDL_Init sdl = spawn SDL_Init("pico-Ceu", WIN_DIM,WIN_DIM, _);
watching sdl do
    {
        WIN = @(&&sdl!.win);
        //REN = @(&&sdl!.ren);
    }
    emit WINDOW_SET_SIZE(WIN_DIM,WIN_DIM,WIN_DIM,WIN_DIM);
    emit FRAMES_SET_CLEAR_RGB(0x00,0x00,0x00);
    emit GFX_SET_RGB(0x00,0x00,0x00);
    emit GFX_CLEAR();
    emit GFX_SET_RGB(0xFF,0xFF,0xFF);

    emit GFX_SET_TEXT_FONT("pico-ceu/FreeMono.ttf", 10);
    do finalize with
        {TTF_CloseFont(FNT);}
    end

    par/or do
        /* FRAMES */
        par do
            // DT -> UPDATE
            loop do
                var int dt = await SDL_DT;
                await async (dt) do
                    emit FRAMES_UPDATE(dt);
                end
            end
        with
            // REDRAW -> FRAMES_REDRAW
            loop do
                await SDL_REDRAW;
                await async do
                    emit FRAMES_REDRAW;
                end
            end
        with
            // BACKGROUND
            every FRAMES_REDRAW do
                if {FRAMES_SET} as bool then
                    var int r = _;
                    var int g = _;
                    var int b = _;
                    _SDL_GetRenderDrawColor({REN}, &&r as u8&&, &&g as u8&&, &&b as u8&&, null);
                    emit GFX_SET_RGB({FRAMES_SET_CLEAR_RGB.r},
                                     {FRAMES_SET_CLEAR_RGB.g},
                                     {FRAMES_SET_CLEAR_RGB.b});
                    emit GFX_CLEAR();
                    emit GFX_SET_RGB(r,g,b);
                end
            end
        end
    with
        /* KEY */
        par do
            // PRESS -> PRESS(true)
            loop do
                var _SDL_KeyboardEvent&& key = await SDL_KEYDOWN;
                var _SDL_Keycode sym = key:keysym.sym;
                await async (sym) do
                    emit KEY_PRESS(true,sym);
                end
            end
        with
            // RELEASE -> PRESS(false)
            loop do
                var _SDL_KeyboardEvent&& key = await SDL_KEYUP;
                var _SDL_Keycode sym = key:keysym.sym;
                await async (sym) do
                    emit KEY_PRESS(false,sym);
                end
            end
        end
    with
        /* MOUSE */
        par do
            // DOWN -> CLICK(true)
            loop do
                var _SDL_MouseButtonEvent&& mse = await SDL_MOUSEBUTTONDOWN;
                var int x = {@mse:x};
                var int y = {@mse:y};
                await async (x,y) do
                    emit MOUSE_CLICK(true,0,x,y);
                end
            end
        with
            // UP -> CLICK(false)
            loop do
                var _SDL_MouseButtonEvent&& mse = await SDL_MOUSEBUTTONUP;
                var int x = {@mse:x};
                var int y = {@mse:y};
                await async (x,y) do
                    emit MOUSE_CLICK(false,0,x,y);
                end
            end
        with
            // MOTION -> MOVE
            var int x = {U16_MAX};
            var int y = {U16_MAX};
            loop do
                var _SDL_MouseMotionEvent&& mse = await SDL_MOUSEMOTION;
                var int x_ = {@mse:x};
                var int y_ = {@mse:y};
                if x_!=x or y_!=y then
                    x = x_;
                    y = y_;
                    await async (x,y) do
                        emit MOUSE_MOVE(x,y);
                    end
                end
            end
        end
    with
        #define _STRINGIFY(X) #X
        #define STRINGIFY(X) _STRINGIFY(X)
        #include STRINGIFY(APP_SRC)
    end
end

escape 0;
